<!DOCTYPE html>
<html lang="de">
<head>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0" />
  <title>Claude Soccer Slime</title>
  <script src="https://cdnjs.cloudflare.com/ajax/libs/react/18.2.0/umd/react.production.min.js"></script>
  <script src="https://cdnjs.cloudflare.com/ajax/libs/react-dom/18.2.0/umd/react-dom.production.min.js"></script>
  <script src="https://cdnjs.cloudflare.com/ajax/libs/babel-standalone/7.23.2/babel.min.js"></script>
  <style>
    *, *::before, *::after { box-sizing: border-box; margin: 0; padding: 0; }
    body { background: #111827; color: #fff; font-family: sans-serif; display: flex; justify-content: center; align-items: center; min-height: 100vh; }
    button { cursor: pointer; font-family: inherit; }
    .center { display: flex; flex-direction: column; align-items: center; justify-content: center; min-height: 100vh; }
    .title { font-size: 2.5rem; font-weight: bold; margin-bottom: 1.5rem; }
    .subtitle { color: #9ca3af; margin-bottom: 0.4rem; }
    .btn { padding: 0.75rem 1.5rem; background: #1e3a8a; border: 2px solid #4b5563; border-radius: 6px; color: #fff; font-size: 1rem; transition: background 0.2s; }
    .btn:hover { background: #1d4ed8; }
    .btn-sm { padding: 0.4rem 1rem; background: #374151; border: 2px solid #4b5563; border-radius: 6px; color: #fff; font-size: 0.85rem; }
    .btn-sm:hover { background: #4b5563; }
    .row { display: flex; gap: 1rem; margin: 1rem 0; flex-wrap: wrap; justify-content: center; }
    .scorebar { background: #1d4ed8; padding: 0.75rem 2rem; border-radius: 8px 8px 0 0; width: 800px; display: flex; justify-content: space-between; align-items: center; font-size: 1.1rem; font-weight: bold; }
    canvas { border: 4px solid #374151; display: block; }
    .controls-hint { font-size: 0.8rem; color: #9ca3af; margin-top: 0.5rem; }
    .winner-box { margin-top: 2rem; text-align: center; }
    .winner-box h2 { font-size: 2rem; margin-bottom: 1rem; }
    .vs { color: #d1d5db; margin: 0 0.75rem; }
  </style>
</head>
<body>
<div id="root"></div>
<script type="text/babel">
const { useState, useEffect, useRef, useCallback } = React;

const GW = 800, GH = 400, GND = 80, SR = 40, BR = 10, GW2 = 80, GH2 = 120;
const GRAV = 0.6, SPD = 5, JUMP = -12, DAMP = 0.99, BDAMP = 0.8, MAXSPD = 13;

const initState = () => ({
  ls: { x:200, y:GH-GND, vx:0, vy:0, grab:false, hasBall:false, glt:0, tx:200, cd:0, fresh:true, lastBy:GH-GND, stuck:0 },
  rs: { x:600, y:GH-GND, vx:0, vy:0, grab:false, hasBall:false, glt:0 },
  ball: { x:GW/2, y:150, vx:0, vy:0, held:null, ang:0, angV:0 }
});

export default function App() {
  const canvasRef = useRef(null);
  const animRef = useRef(null);
  const keys = useRef({});
  const gs = useRef(initState());
  const lastT = useRef(0);

  const [screen, setScreen] = useState('menu'); // menu | mode | game | over
  const [playerMode, setPlayerMode] = useState('single');
  const [timeLeft, setTimeLeft] = useState(0);
  const [score, setScore] = useState({ l:0, r:0 });
  const [winner, setWinner] = useState('');

  useEffect(() => {
    const dn = e => { if(e.target.tagName==='INPUT') return; e.preventDefault(); keys.current[e.key.toLowerCase()] = true; };
    const up = e => { if(e.target.tagName==='INPUT') return; e.preventDefault(); keys.current[e.key.toLowerCase()] = false; };
    window.addEventListener('keydown', dn);
    window.addEventListener('keyup', up);
    return () => { window.removeEventListener('keydown', dn); window.removeEventListener('keyup', up); };
  }, []);

  useEffect(() => {
    if (screen !== 'game') return;
    const timer = setInterval(() => {
      setTimeLeft(t => {
        if (t <= 1) {
          clearInterval(timer);
          setScreen('over');
          return 0;
        }
        return t - 1;
      });
    }, 1000);
    return () => clearInterval(timer);
  }, [screen]);

  const resetPos = () => { gs.current = initState(); };

  const goal = useCallback((side) => {
    setScore(prev => {
      const next = side === 'l' ? { l: prev.l+1, r: prev.r } : { l: prev.l, r: prev.r+1 };
      return next;
    });
    resetPos();
  }, []);

  const updateAI = useCallback(() => {
    const { ls: ai, rs: opp, ball } = gs.current;
    if (ai.cd > 0) {
      ai.cd--;
      const diff = ai.tx - ai.x;
      ai.vx = Math.abs(diff) > 10 ? Math.sign(diff) * SPD * Math.min(Math.abs(diff)/50, 1) : 0;
      return;
    }
    if (ai.fresh && timeLeft > 55) {
      ai.tx = 200; ai.vx = 0;
      if (Math.abs(ball.x - ai.x) < 150 || timeLeft <= 55) { ai.fresh = false; ai.cd = 15; }
      return;
    }
    const ballH = GH - GND - ball.y;
    const aiDist = Math.abs(ai.x - ball.x);
    const ballToAIGoal = Math.abs(ball.x - GW2/2);
    const ballToOppGoal = Math.abs(ball.x - (GW - GW2/2));
    const ballLeft = ball.vx < -1;

    // Stuck detection
    if (Math.abs(ball.y - ai.lastBy) < 5 && Math.abs(ball.vx) < 2) ai.stuck++;
    else ai.stuck = 0;
    ai.lastBy = ball.y;

    let newTx = ai.tx, jump = false;

    if (ballToOppGoal < ballToAIGoal * 1.5 || (ball.x > GW*0.35 && !ballLeft)) {
      newTx = ball.x - (ballH > 60 && aiDist < 150 ? 45 : 30);
      if (aiDist < 100) {
        if (ai.stuck > 30) { jump = true; newTx = ball.x - 40; }
        else if ((ballH > 30 && ballH < 90) || (ball.x > GW*0.6 && ballH < 120)) {
          if (ai.y >= GH-GND-1) jump = true;
        }
      }
    } else if (ball.x < GW*0.65 || ballLeft) {
      newTx = ball.x;
      if (ball.x < GW2*2.5 && ballLeft) {
        newTx = Math.max(ball.x - 10, SR);
        if (aiDist < 120 && ballH < 100) jump = true;
      }
    } else {
      newTx = GW * 0.4;
    }

    if (Math.abs(newTx - ai.tx) > 15) { ai.tx = newTx; ai.cd = 10; }
    const diff = ai.tx - ai.x;
    ai.vx = Math.abs(diff) > 10 ? Math.sign(diff) * SPD * Math.min(Math.abs(diff)/50, 1) : 0;
    if (jump && ai.vy === 0) ai.vy = JUMP;
  }, [timeLeft]);

  const physics = useCallback(() => {
    const { ls, rs, ball } = gs.current;
    const k = keys.current;

    if (playerMode === 'multi') {
      ls.vx = k['a'] ? -SPD : k['d'] ? SPD : 0;
      if (k['w'] && ls.y >= GH-GND-1 && !ls.grab) ls.vy = JUMP;
      ls.grab = !!k['s'];
      rs.vx = k['arrowleft'] ? -SPD : k['arrowright'] ? SPD : 0;
      if (k['arrowup'] && rs.y >= GH-GND-1 && !rs.grab) rs.vy = JUMP;
      rs.grab = !!k['arrowdown'];
    } else {
      updateAI();
      rs.vx = k['arrowleft'] ? -SPD : k['arrowright'] ? SPD : 0;
      if (k['arrowup'] && rs.y >= GH-GND-1 && !rs.grab) rs.vy = JUMP;
      rs.grab = !!k['arrowdown'];
    }

    [ls, rs].forEach((s, i) => {
      s.vy += GRAV; s.x += s.vx; s.y += s.vy;
      if (s.x < SR) s.x = SR;
      if (s.x > GW-SR) s.x = GW-SR;
      if (s.y > GH-GND) { s.y = GH-GND; s.vy = 0; }
      const inOwn = (i===0 && s.x < GW2) || (i===1 && s.x > GW-GW2);
      if (inOwn) {
        s.glt += 1/60;
        if (s.glt >= 1) { goal(i===0 ? 'r' : 'l'); }
      } else s.glt = 0;
    });

    if (ball.held) {
      const g = ball.held === 'l' ? ls : rs;
      const dir = ball.held === 'l' ? 1 : -1;
      ball.angV += -g.vx * 0.008 * dir;
      ball.angV *= 0.85;
      ball.ang += ball.angV;
      const dist = SR + BR - 5;
      ball.x = g.x + Math.cos(ball.ang) * dist;
      ball.y = g.y + Math.sin(ball.ang) * dist;
      ball.vx = g.vx; ball.vy = g.vy;
      if (!g.grab) {
        const spd2 = Math.abs(ball.angV) * 20;
        ball.vx = g.vx*1.5 + Math.cos(ball.ang)*(3+spd2);
        ball.vy = g.vy-2 + Math.sin(ball.ang)*spd2*0.3;
        ball.held = null; ball.ang = 0; ball.angV = 0; g.hasBall = false;
      }
    } else {
      ball.vy += GRAV; ball.vx *= DAMP; ball.x += ball.vx; ball.y += ball.vy;
    }

    if (ball.x < BR) { ball.x = BR; ball.vx = -ball.vx * BDAMP; }
    if (ball.x > GW-BR) { ball.x = GW-BR; ball.vx = -ball.vx * BDAMP; }
    if (ball.y > GH-GND-BR) { ball.y = GH-GND-BR; ball.vy = -ball.vy * BDAMP; }
    if (ball.y < BR) { ball.y = BR; ball.vy = -ball.vy * BDAMP; }

    if (ball.x <= BR && ball.y > GH-GND-GH2) { goal('r'); return; }
    if (ball.x >= GW-BR && ball.y > GH-GND-GH2) { goal('l'); return; }

    [ls, rs].forEach((s, i) => {
      const sn = i===0 ? 'l' : 'r';
      const dx = ball.x-s.x, dy = ball.y-s.y;
      const dist = Math.sqrt(dx*dx+dy*dy);
      if (dist < SR+BR) {
        if (ball.held && ball.held !== sn) {
          const other = ball.held==='l' ? ls : rs;
          const sp = Math.sqrt(s.vx*s.vx+s.vy*s.vy);
          if (sp > 2 || Math.abs(s.vy) > 5) {
            ball.held = null; other.hasBall = false;
            const a = Math.atan2(dy, dx);
            ball.vx = Math.cos(a)*8+s.vx; ball.vy = Math.sin(a)*8+s.vy;
          }
        } else if (s.grab && !ball.held) {
          ball.held = sn; ball.ang = Math.atan2(dy, dx); ball.angV = 0; s.hasBall = true;
        } else if (!ball.held) {
          const a = Math.atan2(dy, dx);
          if (ball.y < s.y || Math.abs(a) < Math.PI*0.5) {
            ball.x = s.x + Math.cos(a)*(SR+BR);
            ball.y = s.y + Math.sin(a)*(SR+BR);
            const sp = Math.sqrt(ball.vx*ball.vx+ball.vy*ball.vy);
            ball.vx = Math.cos(a)*sp*1.5 + s.vx*0.5;
            ball.vy = Math.sin(a)*sp*1.5 + s.vy*0.5;
            const ns = Math.sqrt(ball.vx*ball.vx+ball.vy*ball.vy);
            if (ns > MAXSPD) { ball.vx *= MAXSPD/ns; ball.vy *= MAXSPD/ns; }
          }
        }
      }
    });
  }, [playerMode, updateAI, goal]);

  const draw = useCallback(() => {
    const cv = canvasRef.current; if (!cv) return;
    const ctx = cv.getContext('2d');
    const { ls, rs, ball } = gs.current;
    ctx.fillStyle = '#0000FF'; ctx.fillRect(0,0,GW,GH);
    ctx.fillStyle = '#808080'; ctx.fillRect(0, GH-GND, GW, GND);

    // Goals + nets
    const drawGoal = (flip) => {
      const gx = flip ? GW-GW2 : 0;
      ctx.strokeStyle='#FFF'; ctx.lineWidth=3;
      ctx.beginPath();
      ctx.moveTo(gx,GH-GND); ctx.lineTo(gx+GW2,GH-GND);
      ctx.moveTo(gx+GW2/2,GH-GND); ctx.lineTo(gx+GW2/2,GH-GND-GH2);
      ctx.stroke();
      ctx.strokeStyle='rgba(255,255,255,0.8)'; ctx.lineWidth=1.5;
      for (let x=gx; x<=gx+GW2/2; x+=10) { ctx.beginPath(); ctx.moveTo(x,GH-GND-GH2); ctx.lineTo(x,GH-GND); ctx.stroke(); }
      for (let y=GH-GND-GH2; y<=GH-GND; y+=10) { ctx.beginPath(); ctx.moveTo(gx,y); ctx.lineTo(gx+GW2/2,y); ctx.stroke(); }
    };
    drawGoal(false); drawGoal(true);

    // Slimes
    const drawSlime = (s, isRight, col, acc) => {
      ctx.fillStyle = col;
      ctx.beginPath(); ctx.arc(s.x, s.y, SR, Math.PI, 0); ctx.closePath(); ctx.fill();
      ctx.fillStyle = acc;
      ctx.beginPath(); ctx.arc(s.x, s.y, SR-5, Math.PI+0.3, Math.PI+0.7); ctx.arc(s.x, s.y, SR-15, Math.PI+0.7, Math.PI+0.3, true); ctx.closePath(); ctx.fill();
      const ex = s.x + (isRight ? -SR*0.3 : SR*0.3);
      ctx.fillStyle='#FFF'; ctx.beginPath(); ctx.arc(ex, s.y-SR*0.3, 5, 0, Math.PI*2); ctx.fill();
      ctx.fillStyle='#000'; ctx.beginPath(); ctx.arc(s.x+(isRight?-SR*0.35:SR*0.35), s.y-SR*0.3, 2, 0, Math.PI*2); ctx.fill();
    };
    drawSlime(ls, false, '#00CED1','#008B8B');
    drawSlime(rs, true,  '#DC143C','#8B0000');

    // Ball
    ctx.fillStyle='#FFD700'; ctx.beginPath(); ctx.arc(ball.x, ball.y, BR, 0, Math.PI*2); ctx.fill();
  }, []);

  const loop = useCallback((t) => {
    if (t - lastT.current >= 1000/60) { physics(); draw(); lastT.current = t; }
    animRef.current = requestAnimationFrame(loop);
  }, [physics, draw]);

  useEffect(() => {
    if (screen === 'game') { animRef.current = requestAnimationFrame(loop); }
    return () => cancelAnimationFrame(animRef.current);
  }, [screen, loop]);

  const startGame = (seconds) => {
    resetPos(); setScore({l:0,r:0}); setWinner(''); setTimeLeft(seconds); setScreen('game');
  };

  useEffect(() => {
    if (screen === 'over') {
      const {l,r} = score; // note: score state might lag ‚Äì read from closure
      setWinner(l > r ? 'Cyan-Team' : r > l ? 'Rot-Team' : 'Unentschieden');
    }
  }, [screen]);

  const fmt = s => `${String(Math.floor(s/60)).padStart(2,'0')}:${String(s%60).padStart(2,'0')}`;

  return (
    <div className="center">
      {screen === 'menu' && (
        <>
          <h1 className="title">‚öΩ Claude Soccer Slime</h1>
          <p className="subtitle">Urspr√ºnglich von Quin Pendragon</p>
          <p className="subtitle" style={{marginBottom:'2rem'}}>Adaptiert von Claude</p>
          <div className="row">
            <button className="btn" onClick={() => { setPlayerMode('single'); setScreen('mode'); }}>Einzelspieler</button>
            <button className="btn" onClick={() => { setPlayerMode('multi'); setScreen('mode'); }}>Mehrspieler</button>
          </div>
        </>
      )}

      {screen === 'mode' && (
        <>
          <h2 style={{fontSize:'1.5rem',marginBottom:'1rem'}}>Spieldauer w√§hlen</h2>
          <div style={{fontSize:'1.1rem',marginBottom:'1rem'}}>
            <span style={{color:'#00CED1'}}>Cyan</span>
            <span className="vs">vs</span>
            <span style={{color:'#DC143C'}}>Rot</span>
          </div>
          <div className="row">
            {[[60,'1 Minute'],[120,'2 Minuten'],[240,'4 Minuten'],[480,'8 Minuten'],[300,'World Cup']].map(([s,l]) =>
              <button key={s} className="btn" onClick={() => startGame(s)}>{l}</button>
            )}
          </div>
          <p className="controls-hint" style={{marginTop:'1rem'}}>
            {playerMode==='multi'
              ? 'Links: W/A/D + S (fangen) ¬∑ Rechts: Pfeiltasten + ‚Üì (fangen)'
              : 'Du spielst Rot (rechts): Pfeiltasten ¬∑ ‚Üì = Ball fangen'}
          </p>
          <button className="btn-sm" style={{marginTop:'1rem'}} onClick={() => setScreen('menu')}>‚Üê Zur√ºck</button>
        </>
      )}

      {(screen === 'game' || screen === 'over') && (
        <>
          <div className="scorebar">
            <span style={{color:'#00CED1'}}>Cyan: {score.l}</span>
            <span style={{fontFamily:'monospace',fontSize:'1.4rem'}}>{fmt(timeLeft)}</span>
            <span style={{color:'#DC143C'}}>{score.r} :Rot</span>
          </div>
          <canvas ref={canvasRef} width={GW} height={GH} />
          {screen === 'over' && (
            <div className="winner-box">
              <h2>{winner === 'Unentschieden' ? 'ü§ù Unentschieden!' : `üèÜ ${winner} gewinnt!`}</h2>
              <button className="btn" onClick={() => setScreen('menu')}>Zur√ºck zum Men√º</button>
            </div>
          )}
        </>
      )}
    </div>
  );
}
</script>
<script>
  const root = ReactDOM.createRoot(document.getElementById('root'));
  root.render(React.createElement(App));
</script>
</body>
</html>